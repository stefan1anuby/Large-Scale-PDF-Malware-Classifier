package e2e_test

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"user-service/internal/api/router"
	"user-service/internal/service/auth"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func setupTestRouter() *gin.Engine {
    authService, _ := auth.NewAuthService(auth.WithMemoryUserRepository()) 

    defaultRouter := gin.Default()
    testGroup := defaultRouter.Group("/test")
    router.SetupRouter(testGroup, authService)

    return defaultRouter
}


type UserCredentials struct {
    Username string `json:"username"`
    Email    string `json:"email"`
    Password string `json:"password"`
}

func TestRegisterLoginChangePasswordE2E(t *testing.T) {
    router := setupTestRouter()

    // Step 1: Register a new user
    newUser := UserCredentials{
        Username: "newtestuser",
        Email:    "newtestuser@example.com",
        Password: "initialPassword123",
    }
    testRegister(t, router, newUser)

    // Step 2: Log in with the new user
    token := testLogin(t, router, newUser)

    // Step 3: Change the user's password
    newPassword := "newPassword123"
    testChangePassword(t, router, token, newPassword)

    // Step 4: Log in with the new password
    newUser.Password = newPassword
    testLogin(t, router, newUser)

    // Step 5: Test add user credits
    testAddUserCredits(t, router, token)

    // Step 6: Test get user credits
    testGetUserCredits(t, router, token)

    // Step 7: Test consume user credits (should succeed)
    testConsumeUserCredits(t, router , token)

    // Step 8: Test consume user credits (should fail because no credit left)
    testConsumeUserCreditsShouldFail(t, router, token)
}

func testRegister(t *testing.T, router *gin.Engine, credentials UserCredentials) {
     // Prepare the request payload
    payload := map[string]string{
        "username": credentials.Username,
		"email": 	credentials.Email,
        "password": credentials.Password,
    }
    payloadBytes, _ := json.Marshal(payload)

    // Create a request to the login endpoint
    req, _ := http.NewRequest("POST", "/test/register", bytes.NewBuffer(payloadBytes))
    req.Header.Set("Content-Type", "application/json")

    // Record the response
    recorder := httptest.NewRecorder()
    router.ServeHTTP(recorder, req)

    // Assert the response
    assert.Equal(t, http.StatusOK, recorder.Code, "Expected status OK")
}

func testLogin(t *testing.T, router *gin.Engine, credentials UserCredentials) string {
    
    payload := map[string]string{
        "username": credentials.Username,
		"email": 	credentials.Email,
        "password": credentials.Password,
    }
    payloadBytes, _ := json.Marshal(payload)

    req, _ := http.NewRequest("POST", "/test/login", bytes.NewBuffer(payloadBytes))
    req.Header.Set("Content-Type", "application/json")
    recorder := httptest.NewRecorder()
    router.ServeHTTP(recorder, req)
    assert.Equal(t, http.StatusOK, recorder.Code, "Login failed")

    // Extract the token from the response
    var respBody map[string]string
    json.Unmarshal(recorder.Body.Bytes(), &respBody)
    token := respBody["token"]
    assert.NotEmpty(t, token, "Token should not be empty")

    return token
}

func testChangePassword(t *testing.T, router *gin.Engine, token string, newPassword string) {
    reqBody, _ := json.Marshal(map[string]string{"new_password": newPassword})
    req, _ := http.NewRequest("POST", "/test/change-password", bytes.NewBuffer(reqBody))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", token)
    recorder := httptest.NewRecorder()
    router.ServeHTTP(recorder, req)
    assert.Equal(t, http.StatusOK, recorder.Code, "Password change failed")
}

func testAddUserCredits(t *testing.T, router *gin.Engine, token string) {
    amount := 1
    payload := map[string]int{
        "amount": amount,
    }

    reqBody, _ := json.Marshal(payload)
    req, _ := http.NewRequest("POST", "/test/add-user-credits", bytes.NewBuffer(reqBody))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", token)
    recorder := httptest.NewRecorder()
    router.ServeHTTP(recorder, req)
    assert.Equal(t, http.StatusOK, recorder.Code, "Adding user credits request failed")

    var respBody map[string]bool
    json.Unmarshal(recorder.Body.Bytes(), &respBody)
    status := respBody["status"]
    assert.True(t, status)

}

func testGetUserCredits(t *testing.T, router *gin.Engine, token string) {
    
    req, err := http.NewRequest("GET", "/test/get-user-credits", nil)
    if err != nil {
        t.Fatal(err)
    }

    req.Header.Add("Authorization",token)

    recorder := httptest.NewRecorder()
    router.ServeHTTP(recorder, req)

    assert.Equal(t, http.StatusOK, recorder.Code, "Get user credits request failed")

    var respBody map[string]int
    json.Unmarshal(recorder.Body.Bytes(), &respBody)
    credit := respBody["credit"]
    assert.Equal(t, credit, 1)
}

func testConsumeUserCredits(t *testing.T, router *gin.Engine, token string) {
    
    req, err := http.NewRequest("POST", "/test/consume-user-credits", nil)
    if err != nil {
        t.Fatal(err)
    }

    req.Header.Add("Authorization",token)

    recorder := httptest.NewRecorder()
    router.ServeHTTP(recorder, req)

    assert.Equal(t, http.StatusOK, recorder.Code, "Consuming user credits request failed")

    var respBody map[string]bool
    json.Unmarshal(recorder.Body.Bytes(), &respBody)
    status := respBody["status"]
    assert.True(t, status)

}

func testConsumeUserCreditsShouldFail(t *testing.T, router *gin.Engine, token string) {
    
    req, err := http.NewRequest("POST", "/test/consume-user-credits", nil)
    if err != nil {
        t.Fatal(err)
    }

    req.Header.Add("Authorization",token)

    recorder := httptest.NewRecorder()
    router.ServeHTTP(recorder, req)

    assert.Equal(t, http.StatusOK, recorder.Code, "Consuming user credits request failed")

    var respBody map[string]string
    json.Unmarshal(recorder.Body.Bytes(), &respBody)
    no_credit_error := respBody["error"]
    assert.NotEmpty(t,no_credit_error)

}


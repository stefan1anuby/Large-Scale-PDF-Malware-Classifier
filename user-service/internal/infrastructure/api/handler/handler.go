package handler

import (
	"net/http"
	"user-service/internal/infrastructure/api/helper"
	"user-service/internal/service/auth"

	"github.com/gin-gonic/gin"
)

func HandleHealthCheck(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"status": "healthy"})
}

func HandleRegister(c *gin.Context, authService *auth.AuthService) {
	var registerDetails struct {
        Username 	string `json:"username"`
        Email 		string `json:"email"`
		Password 	string `json:"password"`
    }

	if err := c.ShouldBindJSON(&registerDetails); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

    if !helper.IsUsernameValid(registerDetails.Username) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid username"})
        return
    }
    if !helper.IsEmailValid(registerDetails.Email) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid email address"})
        return
    }
    if !helper.IsPasswordValid(registerDetails.Password) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid password"})
        return
    }

	user, err := authService.Register(registerDetails.Username, registerDetails.Email, registerDetails.Password)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"user": user})
}

func HandleLogin(c *gin.Context, authService *auth.AuthService) {
    var loginDetails struct {
        Username string `json:"username"`
        Password string `json:"password"`
    }
    if err := c.ShouldBindJSON(&loginDetails); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    if !helper.IsUsernameValid(loginDetails.Username) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid username"})
        return
    }
    if !helper.IsPasswordValid(loginDetails.Password) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid password"})
        return
    }

    token, err := authService.Login(loginDetails.Username, loginDetails.Password)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"token": token})
}


func HandlePasswordChange(c *gin.Context, authService *auth.AuthService) {
    /*
    TODO
    CHECK WHY THIS DOESN'T WORKS AS IT SHOULD
    */
    var request struct {
        NewPassword string    `json:"new_password"`
    }
    if err := c.ShouldBindJSON(&request); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    if !helper.IsPasswordValid(request.NewPassword) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid password"})
        return
    }

	user, err := helper.GetUserFromContext(c)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to change password"})
        return
	}

    updated_user, err := authService.ChangePassword(user.ID, request.NewPassword)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to change password"})
        return
    }

    if user.HashedPassword != updated_user.HashedPassword {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to change password"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

func HandleDeleteUser(c *gin.Context, authService *auth.AuthService) {

    /*
        TODO
        to be rewriten with helper.GetUserFromContext
    */
	token := c.GetHeader("Authorization")

	user, err := authService.ValidateToken(token)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to delete user"})
        return
	}

    _, err = authService.Delete(user.ID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}

func HandleCheckPermission(c *gin.Context, authService *auth.AuthService) {
	/*
		TODO
		implement this
		or maybe move all the logic to the middleware
	*/

	/*
    userID, err := uuid.Parse(c.Param("id"))
    if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
        return
    }
	
    permission := c.Query("permission")
	
    hasPermission, err := authService.CheckPermission(userID, permission)
    if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check permission"})
        return
    }
	
    c.JSON(http.StatusOK, gin.H{"has_permission": hasPermission})
	*/
	c.JSON(http.StatusOK, gin.H{"has_permission": "NOT IMPLEMENTED"})
}
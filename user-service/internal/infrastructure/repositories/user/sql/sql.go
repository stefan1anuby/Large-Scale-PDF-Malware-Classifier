package sql

import (
	"database/sql"
	"errors"
	"user-service/internal/domain/users"

	"github.com/google/uuid"
	_ "github.com/lib/pq"
)

type SQLUserRepository struct {
    db *sql.DB
}

func NewSQLUserRepository(connStr string) ( *SQLUserRepository,error) {
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, errors.New("Error opening database")
    }

    err = db.Ping()
    if err != nil {
        return nil, err
    }

    return &SQLUserRepository{
        db: db,
    }, nil
}

func (r *SQLUserRepository) GetAll() ([]*users.User, error) {
    var usersList []*users.User
    query := `SELECT id, username, email, hashedpassword, credits FROM users;`
    rows, err := r.db.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var u users.User
        var userID string
        err := rows.Scan(&userID, &u.Username, &u.Email, &u.HashedPassword, &u.Credits)
        if err != nil {
            return nil, err
        }
        u.ID, _ = uuid.Parse(userID)
        usersList = append(usersList, &u)
    }

    if err = rows.Err(); err != nil {
        return nil, err
    }

    return usersList, nil
}

func (r *SQLUserRepository) FindByID(id uuid.UUID) (*users.User, error) {
    u := &users.User{}
    query := `SELECT id, username, email, hashedpassword, credits FROM users WHERE id = $1;`
    row := r.db.QueryRow(query, id)
    var userID string
    if err := row.Scan(&userID, &u.Username, &u.Email, &u.HashedPassword, &u.Credits); err != nil {
        if err == sql.ErrNoRows {
            return nil, users.ErrUserNotFound
        }
        return nil, err
    }
    u.ID, _ = uuid.Parse(userID)

    return u, nil
}

func (r *SQLUserRepository) FindByUsername(username string) (*users.User, error) {
    u := &users.User{}
    query := `SELECT id, username, email, hashedpassword, credits FROM users WHERE username = $1;`
    row := r.db.QueryRow(query, username)
    var userID string
    if err := row.Scan(&userID, &u.Username, &u.Email, &u.HashedPassword, &u.Credits); err != nil {
        if err == sql.ErrNoRows {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    u.ID, _ = uuid.Parse(userID)

    return u, nil
}

func (r *SQLUserRepository) FindByEmail(email string) (*users.User, error) {
    u := &users.User{}
    query := `SELECT id, username, email, hashedpassword, credits FROM users WHERE email = $1;`
    row := r.db.QueryRow(query, email)
    var userID string
    if err := row.Scan(&userID, &u.Username, &u.Email, &u.HashedPassword, &u.Credits); err != nil {
        if err == sql.ErrNoRows {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    u.ID, _ = uuid.Parse(userID)

    return u, nil
}

func (r *SQLUserRepository) Add(user *users.User) error {
    query := `INSERT INTO users (id, username, email, hashedpassword, credits) VALUES ($1, $2, $3, $4, $5);`
    _, err := r.db.Exec(query, user.ID, user.Username, user.Email, user.HashedPassword, user.Credits)
    if err != nil {
        return err
    }

    return nil
}

func (r *SQLUserRepository) Update(user *users.User) error {
    query := `UPDATE users SET username = $1, email = $2, hashedpassword = $3, credits = $4 WHERE id = $5;`
    _, err := r.db.Exec(query, user.Username, user.Email, user.HashedPassword, user.Credits, user.ID)
    if err != nil {
        return err
    }

    return nil
}

func (r *SQLUserRepository) Delete(id uuid.UUID) error {
    query := `DELETE FROM users WHERE id = $1;`
    _, err := r.db.Exec(query, id)
    if err != nil {
        return err
    }

    return nil
}

func (r *SQLUserRepository) DeleteAll() error {
    query := `DELETE FROM users;`
    _, err := r.db.Exec(query)
    if err != nil {
        return err
    }

    return nil
}


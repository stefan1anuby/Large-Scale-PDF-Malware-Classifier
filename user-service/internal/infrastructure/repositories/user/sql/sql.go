package sql

import (
	"database/sql"
	"errors"
	"user-service/internal/domain/users"

	"github.com/google/uuid"
)

type SQLUserRepository struct {
    db *sql.DB
}

func NewSQLUserRepository(connStr string) ( *SQLUserRepository,error) {
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, errors.New("Error opening database")
    }

    err = db.Ping()
    if err != nil {
        return nil, errors.New("Error connecting to the database")
    }

    return &SQLUserRepository{
        db: db,
    }, nil
}

func (r *SQLUserRepository) GetAll() ([]*users.User, error) {
    var users_list []*users.User
    query := `SELECT * FROM users;`
    rows, err := r.db.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var u users.User
        err := rows.Scan(&u.ID , &u.Username , &u.Email , &u.HashedPassword , &u.Credits)
        if err != nil {
            return nil, err
        }
        users_list = append(users_list, &u)
    }

    if err = rows.Err(); err != nil {
        return nil, err
    }

    return users_list, nil
}

func (r *SQLUserRepository) FindByID(id uuid.UUID) (*users.User, error) {
    var u *users.User
    query := `SELECT id, username, email, hashed_password, credits FROM users WHERE id = ?;`
    row := r.db.QueryRow(query, id)
    var userID string
    if err := row.Scan(&userID, &u.Username, &u.Email, &u.HashedPassword, &u.Credits); err != nil {
        if err == sql.ErrNoRows {
            return nil, users.ErrUserNotFound
        }
        return nil, err
    }
    u.ID, _ = uuid.Parse(userID)

    // Logic to retrieve roles

    return u, nil
}

func (r *SQLUserRepository) FindByUsername(username string) (*users.User, error) {
    var u *users.User
    query := `SELECT id, username, email, hashed_password, credits FROM users WHERE username = ?;`
    row := r.db.QueryRow(query, username)
    var userID string
    if err := row.Scan(&userID, &u.Username, &u.Email, &u.HashedPassword, &u.Credits); err != nil {
        if err == sql.ErrNoRows {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    u.ID, _ = uuid.Parse(userID)

    // Logic to retrieve roles

    return u, nil
}

func (r *SQLUserRepository) FindByEmail(email string) (*users.User, error) {
    var u *users.User
    query := `SELECT id, username, email, hashed_password, credits FROM users WHERE email = ?;`
    row := r.db.QueryRow(query, email)
    var userID string
    if err := row.Scan(&userID, &u.Username, &u.Email, &u.HashedPassword, &u.Credits); err != nil {
        if err == sql.ErrNoRows {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    u.ID, _ = uuid.Parse(userID)

    // Logic to retrieve roles

    return u, nil
}

func (r *SQLUserRepository) Add(user *users.User) error {
    query := `INSERT INTO users (id, username, email, hashed_password, credits) VALUES (?, ?, ?, ?, ?);`
    _, err := r.db.Exec(query, user.ID, user.Username, user.Email, user.HashedPassword, user.Credits)
    if err != nil {
        return err
    }
    // Logic to add roles

    return nil
}

func (r *SQLUserRepository) Update(user *users.User) error {
    query := `UPDATE users SET username = ?, email = ?, hashed_password = ?, credits = ? WHERE id = ?;`
    _, err := r.db.Exec(query, user.Username, user.Email, user.HashedPassword, user.Credits, user.ID)
    if err != nil {
        return err
    }
    // Logic to update roles

    return nil
}

func (r *SQLUserRepository) Delete(id uuid.UUID) error {
    query := `DELETE FROM users WHERE id = ?;`
    _, err := r.db.Exec(query, id)
    if err != nil {
        return err
    }

    // Additional logic for deleting related roles, if needed

    return nil
}
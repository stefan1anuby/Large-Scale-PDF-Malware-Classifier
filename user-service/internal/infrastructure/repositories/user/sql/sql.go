package sql

import (
	"database/sql"
	"errors"
	"user-service/internal/domain/users"
)

type SQLUserRepository struct {
    db *sql.DB
}

func NewSQLUserRepository(connStr string) ( *SQLUserRepository,error) {
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, errors.New("Error opening database")
    }

    err = db.Ping()
    if err != nil {
        return nil, errors.New("Error connecting to the database")
    }

    return &SQLUserRepository{
        db: db,
    }, nil
}

func (r *SQLUserRepository) FindByID(id string) (*users.User, error) {
    var user users.User
    query := `SELECT id, username, password FROM users WHERE id = $1;`
    row := r.db.QueryRow(query, id)

    err := row.Scan(&user.ID, &user.Username, &user.HashedPassword)
    if err != nil {
        return nil, err
    }

    // Load roles and permissions if necessary
    // ...

    return &user, nil
}

func (r *SQLUserRepository) Store(user *users.User) error {
    query := `INSERT INTO users (id, username, password) VALUES ($1, $2, $3) ON CONFLICT (id) DO UPDATE SET username = EXCLUDED.username, password = EXCLUDED.password;`
    _, err := r.db.Exec(query, user.ID, user.Username, user.HashedPassword)
    if err != nil {
        return err
    }
    // Handle roles and permissions if necessary
    // ...
    return nil
}

func (r *SQLUserRepository) FindByUsername(username string) (*users.User, error) {
    var user users.User
    query := `SELECT id, username, password FROM users WHERE username = $1;`
    row := r.db.QueryRow(query, username)

    err := row.Scan(&user.ID, &user.Username, &user.HashedPassword)
    if err != nil {
        return nil, err
    }

    // Load roles and permissions if necessary
    // ...

    return &user, nil
}
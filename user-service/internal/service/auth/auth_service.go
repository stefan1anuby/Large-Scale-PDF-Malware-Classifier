package auth

import (
	"errors"
	"strings"
	"time"
	"user-service/internal/domain/roles"
	"user-service/internal/domain/users"
	"user-service/internal/infrastructure/repositories/user/memory"

	"github.com/dgrijalva/jwt-go"
	"github.com/google/uuid"
)

type AuthService struct {
    userRepo users.Repository
    // Other dependencies...
}

type AuthServiceConfiguration func(authService *AuthService) error


var (
    ErrTokenExpired = errors.New("token has expired")
    ErrTokenInvalid = errors.New("token is invalid")

	ErrInvalidCredentials = errors.New("invalid credentials")
    
    ErrRegister = errors.New("register failed")
    ErrDelete = errors.New("delete failed")
)

// TO BE ADDED IN ENV
var (
    JwtKey = []byte("your_secret_key")
    PostgresConnString = ""
)

type Claims struct {
    UserID string `json:"user_id"`
    jwt.StandardClaims
}

func NewAuthService(cfgs ...AuthServiceConfiguration) (*AuthService, error) {
    as := &AuthService{}
    for _, cfg := range cfgs {
        err := cfg(as)
        if err != nil {
            return nil, err
        }
    }
    return as, nil
}

func WithMemoryUserRepository() AuthServiceConfiguration {
    return func(as *AuthService) error {
        as.userRepo = memory.NewMemoryUserRepository()
        return nil
    }
} 

func WithSQLUserRepository() AuthServiceConfiguration {
    return func(as *AuthService) error {
        
        /*
        sqlRepo, err := sql.NewSQLUserRepository(postgresConnString)
        if err != nil {
            return err
        }
        as.userRepo = sqlRepo
        */
        return nil
    }
} 

func (s *AuthService) Login(username, password string) (string, error) {
    /*
        TODO
        sanitize user input
    */

    user, err := s.userRepo.FindByUsername(username)
    if err != nil {
        if err == users.ErrUserNotFound {
            return "", ErrInvalidCredentials
        }
        return "", err
    }

    if !user.CheckPassword(password) {
        return "", ErrInvalidCredentials
    }

    expirationTime := time.Now().Add(30 * time.Minute) // Token expires after 30 minutes
    claims := &Claims{
        UserID: user.ID.String(),
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

    // Create the JWT string
    tokenString, err := token.SignedString(JwtKey)
    if err != nil {
        return "", err
    }

    return tokenString, nil
}

func (s *AuthService) Register(username, email, password string, credit int) (*users.User, error) {
    /*
    TODO
    sanityze input from client  
    */
    username = strings.TrimSpace(username)
    email = strings.TrimSpace(email)
    password = strings.TrimSpace(password)

    if _, err := s.userRepo.FindByUsername(username); err == nil {
        return nil, users.ErrUserAlreadyExists
    }
    if _, err := s.userRepo.FindByEmail(email); err == nil {
        return nil, users.ErrUserAlreadyExists
    }

    user, err := users.NewUser(username, email, password, []roles.Role{} ,credit)
    if err != nil {
        return nil , ErrRegister
    } 

    err = s.userRepo.Add(user)
    if err != nil {
        return nil , ErrRegister
    } 

    return user, nil
}

func (s *AuthService) Delete(userID uuid.UUID) error {

    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return users.ErrUserNotFound
    }

    err = s.userRepo.Delete(user.ID)
    return err
}

func (s *AuthService) ChangePassword(userID uuid.UUID, newPassword string) (*users.User, error){
    /*
    TODO
    sanityze the newPassword
    */
    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return nil, users.ErrUserNotFound
    }

    err = user.ChangePassword(newPassword)
    if err != nil {
        return nil, users.ErrChangingPassFailed
    }

    err = s.userRepo.Update(user)
    return user, err
}

func (s *AuthService) CheckPermission(userID, permission uuid.UUID) (bool, error) {
    /*
        TODO
        Implement permission check logic
    */ 


	return true, nil
}

func (s *AuthService) ValidateToken(tokenString string) (*users.User, error) {

    claims := &Claims{}

    token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return JwtKey, nil
    })

    if err != nil {
        return nil, ErrTokenInvalid
    }

    if !token.Valid {
        return nil, ErrTokenInvalid
    }

    userID, err := uuid.Parse(claims.UserID)
    if err != nil {
        return nil, err
    }

    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return nil, err
    }

    return user, nil
}

func (s *AuthService) ConsumeUserCredit(userID uuid.UUID) (bool, error) {
    
    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return false, users.ErrUserNotFound
    }

    ok := user.ConsumeCredit()
    if !ok {
        return false, nil
    }

    err = s.userRepo.Update(user)
    if err != nil{
        return false, err
    }

	return ok, nil
}

func (s *AuthService) GetUserCredit(userID uuid.UUID) (int, error) {
  
    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return 0,users.ErrUserNotFound
    }

    credits := user.GetCredits()

    err = s.userRepo.Update(user)
    if err != nil{
        return 0, err
    }

	return credits, nil
}

func (s *AuthService) AddUserCredit(userID uuid.UUID , amount int) (bool, error) {
  
    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return false,users.ErrUserNotFound
    }

    ok := user.AddCredits(amount)

    err = s.userRepo.Update(user)
    if err != nil{
        return false, err
    }

	return ok, nil
}




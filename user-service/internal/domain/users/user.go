package users

import (
	"user-service/internal/domain/roles"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// Aggregate
type User struct {
	ID 					uuid.UUID
	Username 			string
	Email 				string
	HashedPassword 	    string // Hashed password
	Roles    			[]roles.Role
}

func NewUser(username, email, password string, roles []roles.Role) (*User,error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }

	return &User{
		ID:       uuid.New(),
		Username: username,
		Email: email,
		HashedPassword: string(hashedPassword),
		Roles:    roles,
	} , nil
}

func (u *User) CheckPassword(password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(u.HashedPassword), []byte(password))
    return err == nil
}

func (u *User) ChangePassword(newPassword string) error {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
    if err != nil {
        return err
    }

    u.HashedPassword = string(hashedPassword)
    return nil
}

func (u *User) AssignRole(role roles.Role) {
    for _, r := range u.Roles {
        if r.ID == role.ID {
            return // Role already assigned
        }
    }
    u.Roles = append(u.Roles, role)
}

func (u *User) HasRole(roleID uuid.UUID) bool {
    for _, role := range u.Roles {
        if role.ID == roleID {
            return true
        }
    }
    return false
}

func (u *User) RemoveRole(roleID uuid.UUID) {
    for i, role := range u.Roles {
        if role.ID == roleID {
            u.Roles = append(u.Roles[:i], u.Roles[i+1:]...)
            break
        }
    }
}

func (u *User) HasPermission(permissionID uuid.UUID) bool {
    for _, role := range u.Roles {
        if role.HasPermission(permissionID) {
            return true
        }
    }
    return false
}


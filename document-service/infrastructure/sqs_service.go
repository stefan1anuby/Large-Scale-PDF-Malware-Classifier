package infrastructure

import (
	"context"
	"fmt"
	"os"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/sqs"
)

type SQSService struct {
	client   *sqs.SQS
	queueURL string
}

func NewSQSService(queueName string) *SQSService {
	
	sess, err := session.NewSession(&aws.Config{
		Region:      aws.String(os.Getenv("AWS_REGION")),
		Credentials: credentials.NewStaticCredentials(os.Getenv("AWS_CRED_ID"), os.Getenv("AWS_CRED_SECRET"), os.Getenv("AWS_CRED_TOKEN")),
	})
	if err != nil {
		fmt.Printf("Failed to create AWS session: %v\n", err)
		return nil
	}

	sqsClient := sqs.New(sess)

	// Attempt to get the queue URL for the given queue name
	getQueueURLInput := &sqs.GetQueueUrlInput{
		QueueName: aws.String(queueName),
	}
	getQueueURLOutput, err := sqsClient.GetQueueUrl(getQueueURLInput)
	if err != nil {
		// If the queue doesn't exist, create it
		fmt.Println("Queue not found, attempting to create it:", queueName)
		createQueueOutput, err := sqsClient.CreateQueue(&sqs.CreateQueueInput{
			QueueName: aws.String(queueName),
		})
		if err != nil {
			fmt.Printf("Failed to create queue: %v\n", err)
			return nil
		}
		fmt.Println("Queue created successfully:", queueName)
		return &SQSService{
			client:   sqsClient,
			queueURL: *createQueueOutput.QueueUrl,
		}
	}

	// If the queue exists, use its URL
	return &SQSService{
		client:   sqsClient,
		queueURL: *getQueueURLOutput.QueueUrl,
	}
}

// ProcessMessages continuously polls and processes messages from the configured SQS queue.
func (s *SQSService) ReadMessages(ctx context.Context, processMessage func(msg string) error) error {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("Context cancelled, stopping message processing")
			return nil
		default:
			output, err := s.client.ReceiveMessage(&sqs.ReceiveMessageInput{
				QueueUrl: aws.String(s.queueURL),
				// Additional options like wait time and max number of messages can be set here
			})
			if err != nil {
				fmt.Printf("Error receiving messages: %v\n", err)
				continue
			}

			for _, msg := range output.Messages {
				processMessage(*msg.Body)

				// Delete the message from the queue if successfully processed
				_, delErr := s.client.DeleteMessage(&sqs.DeleteMessageInput{
					QueueUrl:      aws.String(s.queueURL),
					ReceiptHandle: msg.ReceiptHandle,
				})
				if delErr != nil {
					fmt.Printf("Failed to delete message: %v\n", delErr)
				}
			}
		}
	}
}
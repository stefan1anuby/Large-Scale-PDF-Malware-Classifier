package infrastructure

import (
	"context"
	"document-service/domain"
	"errors"
	"sync"
	"time"
)

// JobResponsePool implements domain.ResultStorage using sync.Map.
type JobResponsePool struct {
    pool sync.Map
}

// NewJobResponsePool creates a new instance of JobResponsePool.
func NewJobResponsePool() *JobResponsePool {
    return &JobResponsePool{}
}

// StoreResult stores a job result in the pool.
func (p *JobResponsePool) StoreResult(ctx context.Context, jobID string, result domain.Result) error {
    p.pool.Store(jobID, result)
    return nil // sync.Map operations don't return an error
}

// RetrieveResult waits for a result to be available in the pool or times out, with customizable timeout and check intervals.
// RetrieveResult waits for a result to be available in the pool or times out.
func (p *JobResponsePool) RetrieveResult(ctx context.Context, jobID string) (*domain.Result, error) {
	const timeout = 60 * time.Second
	const checkInterval = 10 * time.Millisecond

	startTime := time.Now()

	for {
		select {
		case <-ctx.Done():
			// Context was cancelled or expired
			return nil, ctx.Err()
		default:
			// Check if the jobID is present in the pool
			if value, ok := p.pool.Load(jobID); ok {
				if result, ok := value.(domain.Result); ok {
					p.pool.Delete(jobID) // Ensure result is removed once retrieved
					return &result, nil
				}
			}

			// Check for timeout
			if time.Since(startTime) >= timeout {
				return nil, errors.New("timeout waiting for scan result")
			}

			// Sleep a bit before checking again
			time.Sleep(checkInterval)
		}
	}
}


package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/joho/godotenv"

	"math/rand"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/s3/s3manager"
	"github.com/go-redis/redis/v8"
	"github.com/google/uuid"
)

var(
	serviceInstanceKey = "doc-service-" + strconv.Itoa(rand.Intn(100))

	jobResponsePool sync.Map
)

type RedisMessage struct {
	ScanID  uuid.UUID `json:"scan_id"`
	Result  Result `json:"result"`
}

type Result struct {
	PredictedLabel       int     `json:"predicted_label"`
	PredictionConfidence float64 `json:"prediction_confidence"`
}

func handleUpload(w http.ResponseWriter, r *http.Request) {
	/*
	TODO
	I THINK WE SHOULD DO A SEPARATE HANDLER FUNCTION THAT IS CALLED HERE
	*/

	if r.Method != "POST" {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	/*
	TODO
	MAYBE HERE WE SHOULD CALL IF USER HAS PERMISIONS (you can add in-memory cache)
	*/

	// Parse the multipart form in the request
	err := r.ParseMultipartForm(10 << 20) // Limit your max input length!
	if err != nil {
		http.Error(w, "The uploaded file is too big. Please choose an file less than 10MB in size", http.StatusBadRequest)
		return
	}

	// Get handler for filename, size and headers
	file, handler, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "Error Retrieving the File", http.StatusInternalServerError)
		return
	}
	defer file.Close()

	fmt.Printf("Uploaded File: %+v\n", handler.Filename)
	fmt.Printf("File Size: %+v\n", handler.Size)
	fmt.Printf("MIME Header: %+v\n", handler.Header)

	// Connect to S3
	sess, _ := session.NewSession(&aws.Config{
		Region:      aws.String(os.Getenv("AWS_REGION")),
		Credentials: credentials.NewStaticCredentials(
			os.Getenv("AWS_CRED_ID"),
		 	os.Getenv("AWS_CRED_SECRET"), 
			os.Getenv("AWS_CRED_TOKEN")),
	})

	uploader := s3manager.NewUploader(sess)

	/*
	TODO
	MAYBE HERE WE SHOULD CALL THE USER-SERVICE API and check if user has credits
	*/

	// Prepare metadata
	metadata := make(map[string]*string)
    metadata["service-instance-key"] = aws.String(serviceInstanceKey)
	scan_id := uuid.New()
	metadata["scan_id"] = aws.String(scan_id.String())

	// Upload to S3
	_, err = uploader.Upload(&s3manager.UploadInput{
		Bucket: aws.String(os.Getenv("AWS_S3_BUCKET_NAME")),
		Key:    aws.String(os.Getenv("AWS_S3_DIR_UPLOAD") + "/" + handler.Filename),
		Body:   file,
		Metadata: metadata,
	})
	if err != nil {
		fmt.Println("Failed to upload", err)
		http.Error(w, "Failed to upload file", http.StatusInternalServerError)
		return
	}

	fmt.Printf("Successfully Uploaded File\n")

	const timeout = 60 * time.Second
	const checkInterval = 10 * time.Millisecond

	startTime := time.Now()
	for {
		if time.Since(startTime) > timeout {
			fmt.Printf("Sending timeout response to client \n")
			http.Error(w, "Timeout waiting for scan result", http.StatusGatewayTimeout)
			return
		}
		
		// Check if the scan_id is present in the jobResponsePool
		value, ok := jobResponsePool.Load(scan_id);
		if ok {
			// Found the scan_id, process and respond to the client
			response, err := json.Marshal(value)
			if err != nil {
				http.Error(w, "Error marshaling response", http.StatusInternalServerError)
				return
			}

			w.Header().Set("Content-Type", "application/json")
			w.Write(response) // Send the response as JSON
			jobResponsePool.Delete(scan_id)
			return
		}

		// If not found, sleep for a bit before checking again
		time.Sleep(checkInterval)
	}
}

func readFromRedisAndUpdateMap(rdb *redis.Client, ctx context.Context) {
	
	pubsub := rdb.Subscribe(ctx, serviceInstanceKey)
	defer pubsub.Close()

	for {
		// Wait for a message
		msg, err := pubsub.ReceiveMessage(ctx)
		if err != nil {
			fmt.Println("Error receiving message from Redis:", err)
			continue
		}

		// Parse the JSON message
		var redisMsg RedisMessage
		err = json.Unmarshal([]byte(msg.Payload), &redisMsg)
		if err != nil {
			fmt.Println("Error parsing JSON message:", err)
			continue
		}

		// Extract the scan_id and result
		scanID := redisMsg.ScanID
		result := redisMsg.Result

		// Store the result using scan_id as the key
		jobResponsePool.Store(scanID, result)

		fmt.Printf("Stored result for scan_id: %s in jobResponsePool with value: %v \n", scanID, result)
	}
}

func main() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	// Initialize Redis client
	db, _ := strconv.Atoi(os.Getenv("REDIS_DB"))
	rdb := redis.NewClient(&redis.Options{
		Addr:     	os.Getenv("REDIS_ADDR"),
		Password: 	os.Getenv("REDIS_PASS"),  
		DB: 		db,            
	})

	// Start the Redis reading goroutine
	go readFromRedisAndUpdateMap(rdb, context.Background())

	// Set up HTTP server
	http.HandleFunc("/upload", handleUpload)
	fmt.Println("Server is starting on port " + os.Getenv("SERVICE_LISTEN_PORT"))
	http.ListenAndServe(":" + os.Getenv("SERVICE_LISTEN_PORT"), nil)
}

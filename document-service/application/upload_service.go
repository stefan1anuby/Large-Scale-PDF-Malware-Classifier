package application

import (
	"context"
	"document-service/domain"
	"fmt"
)

type UploadService struct {
	documentStorage domain.DocumentStorage
	//redisService *infrastructure.RedisService
	resultStorage domain.ResultStorage
}

func NewUploadService(documentStorage domain.DocumentStorage /*, redisService *infrastructure.RedisService*/ , resultStorage domain.ResultStorage) *UploadService {
	return &UploadService{
		documentStorage: documentStorage,
		//redisService: redisService,
		resultStorage: resultStorage,
	}
}

// HandleUpload manages the uploading of documents to S3 and any associated tasks
// such as updating caches or publishing messages.
func (u *UploadService) HandleUpload(ctx context.Context, doc *domain.Document) (*domain.Result, error) {
	
	fmt.Println("UploadService.HandleUpload called !")
	// Upload the document using the S3StorageService
	if err := u.documentStorage.UploadDocument(doc); err != nil {
		//TODO Handle error
		return nil, err
	}

	fmt.Println("The document is uploaded !")

	// Here you could also interact with RedisService for caching or pub/sub.
	// For example, publishing a message that a new document has been uploaded.
	/*
	if err := u.redisService.PublishDocumentUploadedEvent(ctx, doc); err != nil {
	     return nil, err
	}
	*/
	result, err := u.resultStorage.RetrieveResult(context.Background(), doc.ID.String())
	if err != nil {
		//TODO Handle error
		return nil, err
	}
	fmt.Println("Retrieved the scan result succesfully !")

	return result, nil
}

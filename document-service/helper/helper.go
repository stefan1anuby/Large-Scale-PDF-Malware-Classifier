package helper

import (
	"crypto/md5"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"path/filepath"
	"strings"
)

type UserServiceClient struct {
	adress		string
}

var (
	ErrUserServiceNotConnected = errors.New("coudn't make connection to the user service")

	ErrNoUserCreditsLeft =  errors.New("no user credits left to proceed")
	ErrUnknownError = errors.New("unknown error")
)

func NewUserServiceClient(adress string) (*UserServiceClient, error){
	//TODO add here health check and return error if service is dead or adress is wrong
	userServiceClient := &UserServiceClient{
		adress: adress,
	}
	result, err := userServiceClient.CheckHealthRequest()
	if err != nil {
		return userServiceClient, err
	} else if !result {
		return userServiceClient, ErrUserServiceNotConnected
	}

	return userServiceClient, nil
}


func (usc *UserServiceClient) CheckHealthRequest() (bool, error) {
	verb := "GET"
	url := usc.adress + "/health"

	statusCode, body, err := makeHTTPRequest(url, verb, "")
	if err != nil {
		log.Fatalf("Error making CheckHealth request: %v", err)
		return false, err
	}

	fmt.Printf("Status Code: %d\n", statusCode)
	fmt.Println("Response Body:", body)

	if statusCode == http.StatusOK {
		return true, nil
	}

	return false, ErrUnknownError
}

func (usc *UserServiceClient) CheckUserPermissionRequest(userAuthToken string) (bool, error) {
	return true, nil
}

func (usc *UserServiceClient) CheckUserCreditsRequest(userAuthToken string) (bool, error) {
	return true, nil
}

func (usc *UserServiceClient) ConsumeUserCreditsRequest(userAuthToken string) (bool, error) {
	url := usc.adress + "/consume-user-credits"
	verb := "POST"

	statusCode, body, err := makeHTTPRequest(url, verb, userAuthToken)
	if err != nil {
		log.Fatalf("Error making ConsumeUserCreditsRequest request: %v", err)
		return false, err
	}

	fmt.Printf("Status Code: %d\n", statusCode)
	fmt.Println("Response Body:", body)

	if statusCode == http.StatusOK {
		return true, nil
	} else if statusCode == http.StatusPaymentRequired {
		return false, ErrNoUserCreditsLeft
	}

	return false, ErrUnknownError

}

func makeHTTPRequest(url string, verb string, token string) (int, string, error){

	// Create a new request using http
	req, err := http.NewRequest(verb, url, nil)
	if err != nil {
		log.Fatalf("Error creating request: %v", err)
	}

	// Add the Authorization header to the request
	req.Header.Set("Authorization", token)

	// Create a new HTTP client and execute the request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("Error sending request to API endpoint: %v", err)
	}
	defer resp.Body.Close()

	// Read the response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Error reading response body: %v", err)
	}

	return resp.StatusCode, string(body), nil
}

func GetFileExtension(filename string) (string, error) {
	// Check if the filename is empty
	if filename == "" {
		return "", fmt.Errorf("filename cannot be empty")
	}

	// Extract the file extension
	extension := filepath.Ext(filename)
	if extension == "" {
		return "", fmt.Errorf("file has no extension")
	}

	// Remove the dot from the extension
	cleanExtension := strings.TrimPrefix(extension, ".")
	if cleanExtension == "" {
		return "", fmt.Errorf("file extension is invalid")
	}

	return strings.ToLower(cleanExtension), nil
}

func CalculateFileMD5(file multipart.File) (string, error) {
	// Reset the file pointer to the beginning of the file
	if _, err := file.Seek(0, io.SeekStart); err != nil {
		return "", fmt.Errorf("failed to seek file: %w", err)
	}

	// Create a new MD5 Hash
	hash := md5.New()

	// Copy the file content into the hash writer
	if _, err := io.Copy(hash, file); err != nil {
		return "", fmt.Errorf("failed to copy file content into hash writer: %w", err)
	}

	// Compute the MD5 checksum
	md5sum := hash.Sum(nil)

	// Encode the checksum to a hex-encoded string
	md5str := hex.EncodeToString(md5sum)
	return md5str, nil
}
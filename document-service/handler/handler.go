package handler

import (
	"document-service/application"
	"document-service/domain"
	"document-service/helper"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
)


func HandlerUploadDoc(uploadService *application.UploadService, userServiceClient *helper.UserServiceClient) http.HandlerFunc {
	return func (w http.ResponseWriter, r *http.Request) {

		if r.Method != http.MethodPost {
			http.Error(w, "Only POST method is allowed", http.StatusMethodNotAllowed)
			return
		}

		// Get auth token from user
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			http.Error(w, "Authorization header is required", http.StatusUnauthorized)
			return
		}
		
		fmt.Println("Authorization Header:", authHeader)
		ok, err := userServiceClient.ConsumeUserCreditsRequest(authHeader)
		if err == helper.ErrNoUserCreditsLeft {
			http.Error(w, "No credits left", http.StatusPaymentRequired)
			return
		} else if err != nil || !ok  {
			http.Error(w, "Querying about this user failed", http.StatusInternalServerError)
			return
		}

		// Parse the multipart form in the request
		err = r.ParseMultipartForm(10 << 20) // For example, the maxMemory is set to 10MB
		if err != nil {
			http.Error(w, "The uploaded file is too big. Please choose a file less than 10MB in size", http.StatusBadRequest)
			return
		}

		// FormFile returns the first file for the given key 'file', it also returns the FileHeader
		// so we can get the Filename, Header and the size of the file
		file, handler, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "Error Retrieving the File", http.StatusInternalServerError)
			return
		}
		defer file.Close()

		// Create a Document instance to pass to the UploadService
		doc := &domain.Document{
			ID:       uuid.New(),
			FileName: handler.Filename,
			Size:     handler.Size,
			File:     file,
		}

		// Call the UploadService to handle the file upload
		result, err := uploadService.HandleUpload(r.Context(), doc)
		if err != nil {
			http.Error(w, "Failed to scan document", http.StatusInternalServerError)
			return
		}


		// Respond to the client with the result of the upload
		response, err := json.Marshal(result)
		if err != nil {
			http.Error(w, "Error marshaling response", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		w.Write(response) // Send the response as JSON
	}
}
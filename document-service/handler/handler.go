package handler

import (
	"document-service/application"
	"document-service/domain"
	"document-service/helper"
	"encoding/json"
	"net/http"
	"time"

	log "github.com/sirupsen/logrus"
)


func HandlerUploadDoc(uploadService *application.UploadService, userServiceClient *helper.UserServiceClient) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		requestStartTime := time.Now() // Track the start time of the request

		if r.Method != http.MethodPost {
			log.Error("Only POST method is allowed")
			http.Error(w, "Only POST method is allowed", http.StatusMethodNotAllowed)
			return
		}

		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			log.Warn("Authorization header is required")
			http.Error(w, "Authorization header is required", http.StatusUnauthorized)
			return
		}

		log.Info("Authorization Header received")

		// Timing the user credits check (if uncommented in production)
		userCreditsCheckStart := time.Now()
		/*
			UNCOMMENT THIS IN PRODUCTION
			ok, err := userServiceClient.ConsumeUserCreditsRequest(authHeader)
			if err == helper.ErrNoUserCreditsLeft {
				log.Error("No credits left for user")
				http.Error(w, "No credits left", http.StatusPaymentRequired)
				return
			} else if err != nil || !ok {
				log.WithError(err).Error("Querying about this user failed")
				http.Error(w, "Querying about this user failed", http.StatusInternalServerError)
				return
			}
		*/
		log.Infof("User credits check completed in %v", time.Since(userCreditsCheckStart))

		// Timing the multipart form parsing
		formParseStart := time.Now()
		err := r.ParseMultipartForm(10 << 20) // For example, the maxMemory is set to 10MB
		if err != nil {
			log.WithError(err).Error("Error parsing multipart form")
			http.Error(w, "The uploaded file is too big. Please choose a file less than 10MB in size", http.StatusBadRequest)
			return
		}
		log.Infof("Form parsing completed in %v", time.Since(formParseStart))

		file, handler, err := r.FormFile("file")
		if err != nil {
			log.WithError(err).Error("Error retrieving the file")
			http.Error(w, "Error Retrieving the File", http.StatusInternalServerError)
			return
		}
		defer file.Close()

		fileMD5 , err := helper.CalculateFileMD5(file)
		if err != nil {
			log.WithError(err).Error("Error calculating file hash")
			http.Error(w, "Error calculating file hash", http.StatusInternalServerError)
			return
		}
		doc := &domain.Document{
			Hash:     fileMD5,
			FileName: handler.Filename,
			Size:     handler.Size,
			File:     file,
		}

		// Timing the document upload handling
		log.Infof("Starting scanning the doc with hash %v",doc.Hash)
		uploadHandlingStart := time.Now()
		result, err := uploadService.HandleUpload(r.Context(), doc)
		if err != nil {
			log.WithError(err).Error("Failed to scan document")
			http.Error(w, "Failed to scan document", http.StatusInternalServerError)
			return
		}
		log.Infof("Upload handling completed in %v", time.Since(uploadHandlingStart))

		response, err := json.Marshal(result)
		if err != nil {
			log.WithError(err).Error("Error marshaling response")
			http.Error(w, "Error marshaling response", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		w.Write(response)

		log.Infof("Successfully processed request in %v", time.Since(requestStartTime))
	}
}
package handler

import (
	"document-service/application"
	"document-service/domain"
	"document-service/helper"
	"encoding/json"
	"net/http"
	"time"

	log "github.com/sirupsen/logrus"
)


func HandlerUploadDoc(uploadService *application.UploadService, userServiceClient *helper.UserServiceClient) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		requestStartTime := time.Now() // Track the start time of the request
		funcCall := "HandlerUploadDoc"

		if r.Method != http.MethodPost {
			log.WithField("funcCal", funcCall).Error("Only POST method is allowed")
			http.Error(w, "Only POST method is allowed", http.StatusMethodNotAllowed)
			return
		}

		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			log.WithField("funcCal", funcCall).Warn("Authorization header is required")
			http.Error(w, "Authorization header is required", http.StatusUnauthorized)
			return
		}

		log.WithField("funcCal", funcCall).Info("Authorization Header received")

		// Timing the user credits check (if uncommented in production)
		userCreditsCheckStart := time.Now()
		/*
		UNCOMMENT THIS IN PRODUCTION
		*/
		ok, err := userServiceClient.ConsumeUserCreditsRequest(authHeader)
		if err == helper.ErrNoUserCreditsLeft {
			log.Error("No credits left for user")
			http.Error(w, "No credits left", http.StatusPaymentRequired)
			return
		} else if err != nil || !ok {
			log.WithError(err).Error("Querying about this user failed")
			http.Error(w, "Querying about this user failed", http.StatusInternalServerError)
			return
		}
		log.WithFields(log.Fields{"duration": time.Since(userCreditsCheckStart),"funcCall": funcCall}).Info("User credits check completed")

		// Timing the multipart form parsing
		formParseStart := time.Now()
		err = r.ParseMultipartForm(10 << 20) // For example, the maxMemory is set to 10MB
		if err != nil {
			log.WithField("funcCal", funcCall).WithError(err).Error("Error parsing multipart form")
			http.Error(w, "The uploaded file is too big. Please choose a file less than 10MB in size", http.StatusBadRequest)
			return
		}

		log.WithFields(log.Fields{"duration": time.Since(formParseStart),"funcCall": funcCall}).Info("Form parsing completed")

		file, handler, err := r.FormFile("file")
		if err != nil {
			log.WithField("funcCal", funcCall).WithError(err).Error("Error retrieving the file")
			http.Error(w, "Error Retrieving the File", http.StatusInternalServerError)
			return
		}
		defer file.Close()

		fileMD5 , err := helper.CalculateFileMD5(file)
		if err != nil {
			log.WithField("funcCal", funcCall).WithError(err).Error("Error calculating file hash")
			http.Error(w, "Error calculating file hash", http.StatusInternalServerError)
			return
		}
		doc := &domain.Document{
			Hash:     fileMD5,
			FileName: handler.Filename,
			Size:     handler.Size,
			File:     file,
		}

		// Timing the document upload handling
		log.WithField("funcCal", funcCall).Infof("Starting scanning the doc with hash %v",doc.Hash)
		uploadHandlingStart := time.Now()
		result, err := uploadService.HandleUpload(r.Context(), doc)
		if err != nil {
			log.WithField("funcCal", funcCall).WithError(err).Error("Failed to scan document")
			http.Error(w, "Failed to scan document", http.StatusInternalServerError)
			return
		}
		
		log.WithFields(log.Fields{"duration": time.Since(uploadHandlingStart),"funcCall": funcCall}).Info("Upload handling completed")

		response, err := json.Marshal(result)
		if err != nil {
			log.WithField("funcCal", funcCall).WithError(err).Error("Error marshaling response")
			http.Error(w, "Error marshaling response", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		w.Write(response)

		log.WithFields(log.Fields{"duration": time.Since(requestStartTime),"funcCall": funcCall}).Info("Successfully processed request")
	}
}

func HandleHealthCheck(w http.ResponseWriter, r *http.Request) {
	funcCall := "HandlerUploadDoc"
	log.WithField("funcCal", funcCall).Info("HealthCheck request received")

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)

	response := map[string]string{"status": "healthy"}

	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.WithField("funcCall", funcCall).Error("Failed to encode HealthCheck response")
		return
	}
	log.WithField("funcCal", funcCall).Info("HealthCheck response sent")
}
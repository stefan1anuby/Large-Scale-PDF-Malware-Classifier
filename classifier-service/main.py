from threading import Thread
from dotenv import load_dotenv

import os
import torch
import json
import boto3
import datetime
import logging
import redis

load_dotenv()

sqs = boto3.client('sqs',  
                    aws_access_key_id=os.getenv("AWS_CRED_ID"),
                    aws_secret_access_key=os.getenv("AWS_CRED_SECRET"), 
                    region_name=os.getenv("AWS_REGION"))
r = redis.Redis(
    host=os.getenv("REDIS_ADDR"),
    port=int(os.getenv("REDIS_PORT")),
    db=int(os.getenv("REDIS_DB")))

model = torch.jit.load(os.getenv("MODEL_PATH"))
model.eval()
features_list = []
with open(os.getenv("FEATURES_LIST_PATH"), 'r') as f:
    features_list = json.load(f)

def predict_handler(input_dict):

    input = [input_dict.get(feature,0) for feature in features_list]
    input_tensor = torch.tensor(input, dtype=torch.float32)

    with torch.no_grad():
        malware_confidence = model(input_tensor).item()
        predicted_label = int(malware_confidence > 0.5)
        prediction_confidence = (predicted_label * malware_confidence) + ((1 - predicted_label) * (1 - malware_confidence))
    
    response = {'predicted_label': predicted_label , 'prediction_confidence': prediction_confidence}
    return response

def poll_sqs_messages():
    while True:
        # Receive message from SQS queue
        response = sqs.receive_message(
            QueueUrl=os.getenv("AWS_SQS_URL"),
            MaxNumberOfMessages=int(os.getenv("AWS_SQS_MAX_NUM_MESS")),
            WaitTimeSeconds=int(os.getenv("AWS_SQS_WAIT_SEC"))
        )

        for message in response.get('Messages', []):
            receipt_handle = message['ReceiptHandle']

            # Process message
            body = json.loads(message['Body'])
            print(body)

            features = body['features']
            metadata = body['metadata']

            prediction_response = predict_handler(features)
            print(datetime.datetime.now())

            # Print or log the prediction response
            print(prediction_response)

            # Sending the prediction response to message broker
            channel_name = metadata['service-instance-key']
            scan_id = metadata['scan_id']

            pub_message = {
                "scan_id"   : scan_id,
                "result"    : prediction_response
            }
            print(f"Push to Redis at channel {channel_name} the message : {pub_message}")
            r.publish(channel_name, json.dumps(pub_message))

            # Delete received message from queue
            
            sqs.delete_message(
                QueueUrl=os.getenv("AWS_SQS_URL"),
                ReceiptHandle=receipt_handle
            )
            

def start_sqs_polling_thread():
    sqs_thread = Thread(target=poll_sqs_messages)
    sqs_thread.start()
    return sqs_thread

if __name__ == '__main__':
    print("Worker started")
    poll_sqs_messages()



